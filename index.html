<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P File Sharing</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 50px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    input, button, textarea {
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>P2P File Sharing with WebRTC</h1>
  
  <input type="file" id="fileInput" />
  <button id="sendButton">Send File</button>
  <button id="connectButton">Connect as Receiver</button>
  
  <textarea id="signalingTextarea" placeholder="Copy/Paste signaling data here" rows="10" cols="50"></textarea>
  
  <script>
    const signalingUrl = 'https://<YOUR-CF-WORKER-URL>/';
    const peerId = Math.random().toString(36).substring(7);
    let peerConnection;
    let dataChannel;

    const sendButton = document.getElementById('sendButton');
    const connectButton = document.getElementById('connectButton');
    const fileInput = document.getElementById('fileInput');
    const signalingTextarea = document.getElementById('signalingTextarea');

    // Setup WebRTC connection
    async function setupConnection(isSender) {
      peerConnection = new RTCPeerConnection();

      if (isSender) {
        dataChannel = peerConnection.createDataChannel('fileChannel');
        dataChannel.onopen = () => console.log('Data channel opened');
        dataChannel.onmessage = receiveFile;
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          dataChannel.onopen = () => console.log('Data channel opened');
          dataChannel.onmessage = receiveFile;
        };
      }

      peerConnection.onicecandidate = async (event) => {
        if (event.candidate) {
          await sendSignal({ peerId, message: { candidate: event.candidate } });
        }
      };
    }

    // Send file
    sendButton.onclick = async () => {
      if (!fileInput.files.length) return alert('Please select a file');

      await setupConnection(true);

      const file = fileInput.files[0];
      const CHUNK_SIZE = 16 * 1024;  // 16KB chunks

      dataChannel.onopen = () => {
        const reader = new FileReader();
        reader.onload = async (e) => {
          let offset = 0;
          while (offset < file.size) {
            const chunk = e.target.result.slice(offset, offset + CHUNK_SIZE);
            if (dataChannel.readyState === 'open') {
              dataChannel.send(chunk);
              offset += CHUNK_SIZE;
            } else {
              console.error('Data channel is not open.');
              break;
            }
          }
          dataChannel.send('EOF');  // End of file transfer
        };
        reader.readAsArrayBuffer(file);
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      await sendSignal({ peerId, message: { sdp: peerConnection.localDescription } });
      signalingTextarea.value = JSON.stringify(peerConnection.localDescription);
    };

    // Connect as receiver
    connectButton.onclick = async () => {
      try {
        await setupConnection(false);

        // Get and parse the signaling data entered by the user
        const signal = signalingTextarea.value.trim();
        if (!signal) {
          return alert('Please enter signaling data!');
        }

        const parsedSignal = JSON.parse(signal);

        if (parsedSignal.sdp) {
          // Set remote description and create an answer
          await peerConnection.setRemoteDescription(new RTCSessionDescription(parsedSignal.sdp));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          await sendSignal({ peerId, message: { sdp: peerConnection.localDescription } });
        } else if (parsedSignal.candidate) {
          // Add ICE candidate
          await peerConnection.addIceCandidate(new RTCIceCandidate(parsedSignal.candidate));
        }
      } catch (error) {
        console.error('Error connecting as receiver:', error);
        alert('Error connecting as receiver. Check console for details.');
      }
    };

    // Send signaling message to the Cloudflare Worker
    async function sendSignal(signal) {
      await fetch(signalingUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(signal),
      });
    }

    // Receive file
    function receiveFile(event) {
      const received = event.data;
      if (received === 'EOF') {
        console.log('File transfer complete');
      } else {
        console.log('Received chunk:', received);
        // Handle received file data (e.g., assemble and download)
      }
    }
  </script>
</body>
</html>
